#include "NXCDefs.h"

//float AngleCalculate(float x, float y);
//float HypotenuseCalculate(float x, float y);
//void drive(float distance);
//void aimRobot(float distance, float angle);
float findMotorDegrees(float angle);
//void turnleft (void);
//void find_shortest_distance (void);
//void getInPlace (void);
//float driveStraight(float distance);
//void findNearestWall();

int find_distance_on;
int currentDistance;
int shortestDistance;


inline void findNearestWall(){
    float motorDegrees = findMotorDegrees(7);


    while(find_distance_on == 1){
        currentDistance = SensorUS(IN_1);
        Wait(1000);
        NumOut(0,0,currentDistance);

        if(currentDistance <= 55 && currentDistance < shortestDistance){
            shortestDistance = currentDistance;

            RotateMotor(OUT_B, 100, motorDegrees);
            Off(OUT_B);

        }
        else if(shortestDistance <= 55 && currentDistance > shortestDistance){
              find_distance_on = 0;      // end of loop
              //OnFwd(OUT_B, -75);
              RotateMotor(OUT_B, -100, motorDegrees);
              Off(OUT_B);
        }
        else {
          RotateMotor(OUT_B, 100, motorDegrees);
          Off(OUT_B);
        }
    }

}

task main()
{

    //int adress_1[2] = {1, 250};
    //int adress_2[2] = {1, -250};
    //int adress_3[2] = {0, 250};
    //int adress_4[2] = {0, -250};

    //float pytagoras_vinkel_avstand[2];
    //int aktuellAdress[2] = ;

    /*switch(1) H�r l�gger vi input
    {
             for(int i = 0; i < 2; i++){
                 case 1:
                 aktuellAdress[i] = adress_1[i];
                 break;
                 case 2:
                 aktuellAdress[i] = adress_2[i];
                 break;
                 case 3:
                 aktuellAdress[i] = adress_3[i];
                 break;
                 case 4:
                 aktuellAdress[i] = adress_4[i];
                 break;
             }
    }*/


    // Activating sensor on port 1
    SetSensorLowspeed(IN_1);
    currentDistance = SensorUS(IN_1);
    shortestDistance = currentDistance;
    find_distance_on = 1;       /*start find_shortest_distance */
    findNearestWall();
    /*
    startRiktning();
    pytagoras_vinkel_avstand[0] = AngleCalculate(aktuellAdress[1], 5);
    pytagoras_vinkel_avstand[1] = HypotenuseCalculate(aktuellAdress[1], 5);
    aimRobot(pytagoras_vinkel_avstand[1], pytagoras_vinkel_avstand[0]);
    driveStraight(pytagoras_vinkel_avstand[1]);
    */
}


/*
float AngleCalculate(float x, float y){
    return atand(y-15/x);
}

float HypotenuseCalculate(float x, float y)
{
    return sqrt(x*x+(y-15)*(y-15));loat driveStraight(float distance){
    float wheelCircumference = 17.6; // pi*5.6
    float motorDegrees = (360*distance/wheelCircumference);
    return motorDegrees;
}

void aimRobot(float distance, float angle){
    float motorDegrees = findMotorDegrees(angle);

     // To right
    if(distance > 0){

        RotateMotor(OUT_A, 75, (180-motorDegrees));

    // To left
    } else if (distance < 0){

        RotateMotor(OUT_B, 75, (180-motorDegrees));
    }
}
*/

float findMotorDegrees(float angle){

     float wheelCircumference = 17.6;
     float piTrack = 53.4; // Distance between wheels times pi
     float circumferenceDistance = 2 * piTrack;
     float motorDegrees = angle * circumferenceDistance / wheelCircumference;
     return motorDegrees;

}
