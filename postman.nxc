#include "NXCDefs.h"

float AngleCalculate(float x, float y);
float HypotenuseCalculate(float x, float y);
void drive(float distance);
void aimRobot(float angle);
float findMotorDegrees(float angle);
void turnleft (void);
void find_shortest_distance (void);
void getInPlace (void);
float drive(float distance);




task main()
{
    int adress_1[2] = {1, 250};
    int adress_2[2] = {1, -250};
    int adress_3[2] = {0, 250};
    int adress_4[2] = {0, -250};

    float pytagoras_vinkel_avstand[2];
    int aktuellAdress[2] = { 0 };
    
    switch(1) /* Här lägger vi input */
    {
             for(int i = 0; i < 2; i++){
                 case 1:
                 aktuellAdress[i] = adress_1[i];
                 break;
                 case 2:
                 aktuellAdress[i] = adress_2[i];
                 break;
                 case 3:
                 aktuellAdress[i] = adress_3[i];
                 break;
                 case 4:
                 aktuellAdress[i] = adress_4[i];
                 break;
             }
    }


    // Activating sensor on port 1
    SetSensorLowspeed(IN_1);
    find_shortest_distance();

    // startRiktning();
    pytagoras_vinkel_avstand[0] = AngleCalculate(aktuellAdress[1], 5);  /* ta in sensorns värde inte 5 cm */
    pytagoras_vinkel_avstand[1] = HypotenuseCalculate(aktuellAdress[1], 5);
    aimRobot(aktuellAdress[1], pytagoras_vinkel_avstand[0]);
    drive(pytagoras_vinkel_avstand[1]);
    /* Lämna boken */
}

void turnleft(void)
{
    /* Acquire (engineLock); */
    OnFwd(OUT_AB, 75);
    /* Release (engineLock); */
}

void find_shortest_distance (void)
{
    /* Acquire (engineLock); */
    int currentDistance = SensorUS (IN_2);
    int shortestDistance = currentDistance;
    
    /* Här måste roboten börja köra annars går inte loopen*/

    until (currentDistance != SensorUS (IN_2))
    {
        currentDistance = SensorUS (IN_2);

        if (currentDistance < shortestDistance)
        {
            shortestDistance = currentDistance;
        }
    }
    while (SensorUS (IN_2) != shortestDistance)
    {
        turnleft ();
    }
}

/*
void getInPlace (void)
{
    while (SensorUS (IN_2) != shortestDistance)
    {
        turnleft ();
    }
}
*/

float AngleCalculate(float x, float y)
{
    return atand(y-15/x);
}

float HypotenuseCalculate(float x, float y)
{
    return sqrt(x*x+(y-15)*(y-15));
}

float drive(float distance){
    float wheelCircumference = 17.6; /* pi*5.6 */
    float motorDegrees = 360*distance / wheelCircumference;
    ret
    urn motorDegrees;
}

float findMotorDegrees(float angle){

     float wheelCircumference = 17.6;
     float piTrack = 63; /* Distance between wheels times pi*/
     float circumferenceDistance = 2 * piTrack;
     float motorDegrees = 360 * piTrack / wheelCircumference;
     return motorDegrees;

}

void aimRobot(float angle)
{
    float motorDegrees = findMotorDegrees(angle);

    /* To right */
    if(distance > 0){
    
        RotateMotor(OUT_A, 75, (180-motorDegrees));

    /* To left */
    } else if (distance < 0){
        
        RotateMotor(OUT_B, 75, (180-motorDegrees));
    }
}
