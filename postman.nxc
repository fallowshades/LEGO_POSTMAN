#include "NXCDefs.h"

//float AngleCalculate(float x, float y);
//float HypotenuseCalculate(float x, float y);
void aimRobot(float distance, float angle);
float findMotorDegrees(float angle);
int driveStraight(float distance);
void driveBack(float distance);
void dropBook(void);
int findNearestWall(void);

int find_distance_on;


task main()
{

    int address_1[2] = {1, 250};
    int address_2[2] = {1, -250};
    int address_3[2] = {0, 250};
    int address_4[2] = {0, -250};

    int distanceToWall;

    float pytagoras_vinkel_avstand[2];
    int currentAddress[2];

    switch(1) // Här lägger vi input
    {
             for(int i = 0; i < 2; i++){
                 case 1:
                 currentAddress[i] = address_1[i];
                 break;
                 case 2:
                 currentAddress[i] = address_2[i];
                 break;
                 case 3:
                 currentAddress[i] = address_3[i];
                 break;
                 case 4:
                 currentAddress[i] = address_4[i];
                 break;
             }
    }


    // Activating sensor on port 1
    SetSensorLowspeed(IN_1);
    SetSensor(IN_2,SENSOR_TOUCH);
    SetSensor(IN_3,SENSOR_TOUCH);
    distanceToWall = findNearestWall();
    //pytagoras_vinkel_avstand[0] = AngleCalculate(aktuellAdress[1], distanceToWall);
    //pytagoras_vinkel_avstand[1] = HypotenuseCalculate(aktuellAdress[1], distanceToWall);
    aimRobot(250, 90);
    int h = driveStraight(4000);
    dropBook();
    driveBack(4000);
    aimRobot(250, -90);

    //driveStraight(pytagoras_vinkel_avstand[1]);
}

int findNearestWall(void){
    int currentDistance;
    int shortestDistance;
    float motorDegrees = findMotorDegrees(9);

    OnFwd(OUT_B, 40);
    while (SensorUS(IN_1)<60);
    while (SensorUS(IN_1)>60);
    Off(OUT_B);
    currentDistance = SensorUS(IN_1);
    shortestDistance = currentDistance;
    do {
      shortestDistance = currentDistance;
      NumOut(0,0,currentDistance);
      RotateMotor(OUT_B, 30, motorDegrees);
      Off(OUT_B);
      currentDistance = SensorUS(IN_1);
    }while (shortestDistance>=currentDistance);
    RotateMotor(OUT_B, -30, (motorDegrees*3));
    OnFwdSync(OUT_AB, 80, 0);
    until (SENSOR_3 == 1 || SENSOR_2 == 1);
    if(SENSOR_3 == 1){
      Off(OUT_B);
      until (SENSOR_2 == 1);
      Off(OUT_A);
    } else if (SENSOR_2 == 1){
      Off(OUT_A);
      until (SENSOR_3 == 1);
      Off(OUT_B);
    }
    OnFwdSync(OUT_AB, -50, 0);
    until (SensorUS(IN_1)==15);
    Off(OUT_AB);
    /* while (SensorUS(IN_1)<60);
    while (SensorUS(IN_1)>60);
    Off(OUT_B);
    while (shortestDistance!=currentDistance){
      RotateMotor(OUT_B, 30, motorDegrees);
      Off(OUT_B);
      currentDistance = SensorUS(IN_1);
      NumOut(0,0,currentDistance);
    } */
    //RotateMotor(OUT_B, -30, (motorDegrees*3));
    return shortestDistance;
}

/*
float AngleCalculate(float x, float y){
    return atand((y-15)/x);
} */
/*
float HypotenuseCalculate(float x, float y)
{
    return sqrt(x*x+(y-15)*(y-15));
    float driveStraight(float distance){
    float wheelCircumference = 17.6; // pi*5.6
    float motorDegrees = (360*distance/wheelCircumference);
    return motorDegrees;
}
*/
void aimRobot(float distance, float angle){
    float motorDegrees = findMotorDegrees(angle);

     // To right
    if(distance > 0){
      if(angle>0){
        RotateMotor(OUT_A, -50, motorDegrees);
      } else{
        RotateMotor(OUT_A, 50, -motorDegrees);
      }

    // To left
    } else if (distance < 0){

        RotateMotor(OUT_B, -50, motorDegrees);
    }
}


float findMotorDegrees(float angle){

     float wheelCircumference = 17.6;
     float piTrack = 53.4; // Distance between wheels times pi
     float circumferenceDistance = 2 * piTrack;
     float motorDegrees = angle * circumferenceDistance / wheelCircumference;
     return motorDegrees;

}
int driveStraight(float distance){
      //RotateMotorEx(OUT_AB, -25, 3600, 0, false, true);
      OnFwdSync(OUT_AB, -50, 0);
      Wait(distance);
      int x = MotorRotationCount(OUT_A);
      Off(OUT_AB);
      NumOut(0,0,x);
      return x;
}
void driveBack(float distance){
      //RotateMotorEx(OUT_AB, -25, 3600, 0, false, true);
      OnFwdSync(OUT_AB, 50, 0);
      Wait(distance);
      int x = MotorRotationCount(OUT_A);
      Off(OUT_AB);
      NumOut(0,0,x);
}
void dropBook(void){
  OnFwd(OUT_C, -40);
  Wait(3000);
  Off(OUT_C);
}
